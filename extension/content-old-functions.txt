        } catch (e) {
        }

        try {
            const reactRoot = document.querySelector('[data-reactroot], #board-layout-main, .game-layout-component');
            if (reactRoot) {
                const fiberKey = Object.keys(reactRoot).find(key => key.startsWith('__reactFiber') || key.startsWith('__reactInternalInstance'));
                if (fiberKey) {
                    const fiber = reactRoot[fiberKey];
                    const fen = findFENInFiber(fiber);
                    if (fen) {
                        return fen;
                    } else {
                    }
                } else {
                }
            } else {
            }
        } catch (e) {
        }

        return null;
    }

    function parseBoardToFEN(board) {
        try {
            const squares = board.querySelectorAll('.square, [class*="square"]');
            if (squares.length !== 64) return null;

            let fen = '';
            let empty = 0;

            for (let rank = 7; rank >= 0; rank--) {
                for (let file = 0; file < 8; file++) {
                    const squareIndex = rank * 8 + file;
                    const square = squares[squareIndex];
                    const piece = square.querySelector('.piece, [class*="piece"]');

                    if (piece) {
                        if (empty > 0) {
                            fen += empty;
                            empty = 0;
                        }
                        const pieceClass = piece.className;
                        const fenChar = pieceClassToFEN(pieceClass);
                        if (fenChar) fen += fenChar;
                        else empty++;
                    } else {
                        empty++;
                    }
                }
                if (empty > 0) {
                    fen += empty;
                    empty = 0;
                }
                if (rank > 0) fen += '/';
            }

            fen += ' w KQkq - 0 1'; 

            return fen.match(/^[1-8pnbrqkPNBRQK\/]+/) ? fen : null;
        } catch (e) {
            return null;
        }
    }

    function pieceClassToFEN(className) {
        const map = {
            'wp': 'P', 'wn': 'N', 'wb': 'B', 'wr': 'R', 'wq': 'Q', 'wk': 'K',
            'bp': 'p', 'bn': 'n', 'bb': 'b', 'br': 'r', 'bq': 'q', 'bk': 'k'
        };
        for (let key in map) {
            if (className.includes(key)) return map[key];
        }
        return null;
    }

    function findFENInShadowDOM(shadowRoot) {
        try {

            const allElements = shadowRoot.querySelectorAll('*');
            for (let el of allElements) {
                if (el.getAttribute && (el.getAttribute('data-fen') || el.getAttribute('fen'))) {
                    return el.getAttribute('data-fen') || el.getAttribute('fen');
                }
            }
        } catch (e) {
        }
        return null;
    }

    function findFENInFiber(fiber, depth = 0) {
        if (depth > 20) return null;
        if (!fiber) return null;

        try {

            if (fiber.memoizedProps) {
                if (fiber.memoizedProps.fen) return fiber.memoizedProps.fen;
                if (fiber.memoizedProps.position) return fiber.memoizedProps.position;
            }

            if (fiber.memoizedState) {
                if (typeof fiber.memoizedState === 'string' && fiber.memoizedState.includes('/')) {
                    return fiber.memoizedState;
                }
                if (fiber.memoizedState.fen) return fiber.memoizedState.fen;
                if (fiber.memoizedState.position) return fiber.memoizedState.position;
            }

            if (fiber.child) {
                const childResult = findFENInFiber(fiber.child, depth + 1);
                if (childResult) return childResult;
            }

            if (fiber.sibling) {
                const siblingResult = findFENInFiber(fiber.sibling, depth + 1);
                if (siblingResult) return siblingResult;
            }
        } catch (e) {

        }

        return null;
    }

    async function analyze() {

        const originalText = btn.textContent;

        try {
            btn.textContent = '...';
            btn.disabled = true;

            const fen = getFEN();

            if (!fen) {
                alert('Error: Cannot detect position.\n\nPlease:\n1. Make sure game is loaded\n2. Try making a move first\n3. Try again');
                btn.textContent = originalText;
                btn.disabled = false;
                return;
            }

            const playerColor = getPlayerColor();
            const fenParts = fen.split(' ');
            const turnColor = fenParts[1]; 

            if (playerColor && turnColor) {
                if ((playerColor === 'white' && turnColor !== 'w') || 
                    (playerColor === 'black' && turnColor !== 'b')) {
                    alert('Not your turn!\n\nWait for opponent to move.');
                    btn.textContent = originalText;
                    btn.disabled = false;
                    return;
                }
            }

            const response = await fetch(API_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ fen })
            });

            if (!response.ok) {
                throw new Error(`API returned ${response.status}`);
            }

            const data = await response.json();

            if (data.success && data.bestMoves && data.bestMoves.length > 0) {
                drawArrows(data.bestMoves);
                showMoveList(data.bestMoves);
                btn.textContent = 'OK';
                setTimeout(() => { btn.textContent = originalText; }, 1500);
                watchForMoves();
            } else {
                alert('No good moves found in this position!');
                btn.textContent = originalText;
            }

        } catch (error) {
            alert('Error: ' + error.message + '\n\nPls run start.bat');
            btn.textContent = 'X';
            setTimeout(() => { btn.textContent = originalText; }, 2000);
        } finally {
            btn.disabled = false;
        }
    }

    function getPlayerColor() {
        try {
            const board = document.querySelector('.board, wc-chess-board, chess-board');
            if (!board) return null;

            try {

                const playerBottom = document.querySelector('.player-component.player-bottom, .player-bottom, [class*="player"][class*="bottom"]');
                const playerTop = document.querySelector('.player-component.player-top, .player-top, [class*="player"][class*="top"]');

                if (playerBottom || playerTop) {

                    if (playerBottom) {
                        const isYou = playerBottom.textContent?.toLowerCase().includes('you') ||
                                     playerBottom.className?.includes('user-tagline-username') ||
                                     playerBottom.querySelector('.user-tagline-username');

                        if (isYou) {
                        }
                    }
                }
            } catch (e) {
            }

            if (board.game) {

                if (typeof board.game.getPlayingAs === 'function') {
                    const color = board.game.getPlayingAs();
                    if (color === 1) return 'white';
                    if (color === 2) return 'black';
                }

                if (typeof board.game.getPlayerColor === 'function') {
                    const color = board.game.getPlayerColor();
                    return color;
                }

                if (board.game.playerColor) {
                    return board.game.playerColor;
                }

                if (board.game.myColor) {
                    return board.game.myColor;
                }
            }

            const isFlipped = board.classList.contains('flipped') || 
                            board.className.includes('flipped') ||
                            getComputedStyle(board).transform.includes('rotate(180');

            const orientation = board.getAttribute('orientation') || 
                              board.getAttribute('data-orientation');

            if (orientation) {
                if (orientation === 'black') return 'black';
                if (orientation === 'white') return 'white';
            }

            try {
                const coords = board.querySelectorAll('.coordinate, [class*="coordinate"]');
                if (coords.length > 0) {
                    const bottomCoord = Array.from(coords).find(c => 
                        c.textContent === '1' || c.textContent === '8'
                    );
                    if (bottomCoord) {
                        const isAtBottom = bottomCoord.getBoundingClientRect().bottom > 
                                         board.getBoundingClientRect().top + board.getBoundingClientRect().height / 2;
                        if (isAtBottom) {
                            const color = bottomCoord.textContent === '1' ? 'white' : 'black';
                            return color;
                        }
                    }
                }
            } catch (e) {
            }

            return isFlipped ? 'black' : 'white';

        } catch (e) {

            return 'white';
        }
    }

    function drawArrows(moves) {
        const board = document.querySelector('.board, wc-chess-board, chess-board');
        if (!board) {
            return;
        }

        const oldSvg = document.getElementById('arrows-svg');
        if (oldSvg) oldSvg.remove();

        const rect = board.getBoundingClientRect();
        const size = rect.width;

        const isFlipped = board.classList.contains('flipped') || 
                         board.className.includes('flipped') ||
                         getComputedStyle(board).transform.includes('rotate(180');

        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.id = 'arrows-svg';
        svg.setAttribute('width', size);
        svg.setAttribute('height', size);
        svg.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 999;
        `;

        if (getComputedStyle(board).position === 'static') {
            board.style.position = 'relative';
        }

        const colors = {
            'Goodest': '#15781B',
            'Excellent': '#7fa650',
            'OK': '#999'
        };

        moves.forEach((move) => {
            const m = move.move;
            if (!m || m.length < 4) return;

            const from = m.substring(0, 2);
            const to = m.substring(2, 4);
            const color = colors[move.quality] || '#888';

            const p1 = squareToPixel(from, size, isFlipped);
            const p2 = squareToPixel(to, size, isFlipped);

            const squareSize = size / 8;
            const isCastling = isCastlingMove(from, to);

            if (isCastling) {
                const cornerX = p2.x;
                const cornerY = p1.y;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', `M ${p1.x},${p1.y} L ${cornerX},${cornerY} L ${p2.x},${p2.y}`);
                path.setAttribute('stroke', color);
                path.setAttribute('stroke-width', size / 24);
                path.setAttribute('fill', 'none');
                path.setAttribute('opacity', '0.9');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                svg.appendChild(path);

                const headSize = squareSize * 0.6;
                const triangle = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');

                const angle = Math.atan2(p2.y - cornerY, p2.x - cornerX);

                const tipX = p2.x;
                const tipY = p2.y;
                const baseX = tipX - Math.cos(angle) * headSize;
                const baseY = tipY - Math.sin(angle) * headSize;
                const side1X = baseX - Math.sin(angle) * headSize * 0.5;
                const side1Y = baseY + Math.cos(angle) * headSize * 0.5;
                const side2X = baseX + Math.sin(angle) * headSize * 0.5;
                const side2Y = baseY - Math.cos(angle) * headSize * 0.5;

                triangle.setAttribute('points', `${tipX},${tipY} ${side1X},${side1Y} ${side2X},${side2Y}`);
                triangle.setAttribute('fill', color);
                triangle.setAttribute('opacity', '0.9');
                svg.appendChild(triangle);
            } else {
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const angle = Math.atan2(dy, dx);

                const startX = p1.x + Math.cos(angle) * squareSize * 0.15;
                const startY = p1.y + Math.sin(angle) * squareSize * 0.15;
                const endX = p2.x - Math.cos(angle) * squareSize * 0.5;
                const endY = p2.y - Math.sin(angle) * squareSize * 0.5;

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', startX);
                line.setAttribute('y1', startY);
                line.setAttribute('x2', endX);
                line.setAttribute('y2', endY);
                line.setAttribute('stroke', color);
                line.setAttribute('stroke-width', size / 24);
                line.setAttribute('opacity', '0.9');
                line.setAttribute('stroke-linecap', 'round');
                svg.appendChild(line);

                const headSize = squareSize * 0.6;
                const triangle = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');

                const tipX = p2.x;
                const tipY = p2.y;
                const baseX = tipX - Math.cos(angle) * headSize;
                const baseY = tipY - Math.sin(angle) * headSize;
                const side1X = baseX - Math.sin(angle) * headSize * 0.5;
                const side1Y = baseY + Math.cos(angle) * headSize * 0.5;
                const side2X = baseX + Math.sin(angle) * headSize * 0.5;
                const side2Y = baseY - Math.cos(angle) * headSize * 0.5;

                triangle.setAttribute('points', `${tipX},${tipY} ${side1X},${side1Y} ${side2X},${side2Y}`);
                triangle.setAttribute('fill', color);
                triangle.setAttribute('opacity', '0.9');
                svg.appendChild(triangle);
            }
        });

        board.appendChild(svg);
    }

    function isCastlingMove(from, to) {
        const castlingMoves = ['e1g1', 'e1c1', 'e8g8', 'e8c8'];
        return castlingMoves.includes(from + to);
    }

    function squareToPixel(square, size, isFlipped = false) {
        const file = square.charCodeAt(0) - 97; 

        const rank = parseInt(square[1]) - 1;   

        const sq = size / 8;

        let x, y;

        if (isFlipped) {

            x = (7 - file) * sq + sq / 2;  

            y = rank * sq + sq / 2;         

        } else {

            x = file * sq + sq / 2;
            y = (7 - rank) * sq + sq / 2;
        }

        return { x, y };
    }

    function showMoveList(moves) {
        const existing = document.getElementById('moves-list');
        if (existing) existing.remove();

        const div = document.createElement('div');
        div.id = 'moves-list';
        div.style.cssText = `
            position: fixed;
            top: 130px;
            right: 20px;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 12px;
            border-radius: 6px;
            font-size: 12px;
            font-family: monospace;
            z-index: 99998;
            min-width: 200px;
            border: 1px solid rgba(255,255,255,0.1);
        `;

        const qualityColors = {
            'Goodest': '#15781B',
            'Excellent': '#7fa650',
            'OK': '#999'
        };

        let html = '<div style="font-weight:600;margin-bottom:8px;font-size:13px">Best Moves</div>';

        moves.forEach((m, i) => {
            const color = qualityColors[m.quality];
            html += `
                <div style="margin:5px 0;padding:5px;background:rgba(255,255,255,0.03);border-radius:3px;border-left:2px solid ${color}">
                    <div style="display:flex;justify-content:space-between">
                        <span>${i+1}. ${m.move}</span>
                        <span style="color:#aaa">${m.scorePawns}</span>
                    </div>
                    <div style="font-size:10px;color:${color};margin-top:2px">${m.quality}</div>
                </div>
            `;
        });

        div.innerHTML = html;
        document.body.appendChild(div);
    }

    function watchForMoves() {
        const currentFen = getFEN();
        if (!currentFen) return;

        const checkInterval = setInterval(() => {
            const newFen = getFEN();
            if (newFen && newFen !== currentFen) {
                const svg = document.getElementById('arrows-svg');
                if (svg) svg.remove();
                clearInterval(checkInterval);
            }
        }, 500);

        setTimeout(() => clearInterval(checkInterval), 120000);
    }

    document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.shiftKey && e.key === 'A') {
            e.preventDefault();
            btn.click();
        }
    });

})();

